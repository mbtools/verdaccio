{"version":3,"sources":["../src/index.ts","../src/plugin.ts","../src/utils.ts"],"sourcesContent":["import FilterPlugin, { FilterConfig } from './plugin'\n\nexport { FilterPlugin }\nexport type { FilterConfig }\nexport default FilterPlugin\n","import buildDebug from 'debug'\nimport { Range } from 'semver'\n\nimport { pluginUtils } from '@verdaccio/core'\nimport { Manifest, Config, Logger } from '@verdaccio/types'\n\nimport { PackageBlockRule, ParsedBlockRule } from './types'\nimport { filterBlockedVersions, isScopeRule, isPackageRule, isPackageAndVersionRule } from './utils'\n\nconst debug = buildDebug('verdaccio:plugin:pro:filter')\n\nexport interface FilterConfig extends Config {\n  enabled: boolean\n  block?: Array<PackageBlockRule>\n}\n\nclass FilterPlugin extends pluginUtils.Plugin<FilterConfig> implements pluginUtils.ManifestFilter<FilterConfig> {\n  public config: Config\n  public logger: Logger\n  private readonly parsedConfig: {\n    enabled: boolean\n    block: Map<string, ParsedBlockRule>\n  }\n\n  constructor(config: FilterConfig, options: pluginUtils.PluginOptions) {\n    super(config, options)\n    this.config = options.config\n    this.logger = options.logger\n\n    // convert config.block to map\n    const blockMap = (config.block ?? []).reduce((map, value) => {\n      if (isScopeRule(value)) {\n        if (!value.scope.startsWith('@')) {\n          throw new TypeError(`Scope value must start with @, found: ${value.scope}`)\n        }\n\n        map.set(value.scope, 'scope')\n        return map\n      }\n\n      if (isPackageRule(value)) {\n        map.set(value.package, 'package')\n        return map\n      }\n\n      if (isPackageAndVersionRule(value)) {\n        const previousConfig = map.get(value.package) || { block: [] }\n\n        if (typeof previousConfig === 'string') {\n          return map // use more strict rule\n        }\n\n        try {\n          const range = new Range(value.versions)\n\n          map.set(value.package, { block: [...previousConfig.block, range], strategy: value.strategy ?? 'block' })\n        }\n        catch (e) {\n          this.logger.error('Error parsing rule failed:')\n          this.logger.error(e)\n          this.logger.error('encountered while parsing rule:')\n          this.logger.error(value)\n        }\n\n        return map\n      }\n\n      throw new TypeError(`Could not parse rule ${JSON.stringify(value, null, 4)} in skipChecksFor`)\n    }, new Map<string, ParsedBlockRule>())\n\n    this.parsedConfig = {\n      enabled: config.enabled ?? false,\n      block: blockMap,\n    }\n\n    this.logger.debug(\n      `Loaded plugin-secfilter, ${JSON.stringify(this.parsedConfig, null, 4)}, ${Array.from(\n        this.parsedConfig.block.entries(),\n      )}`,\n    )\n\n    debug('Verdaccio Pro filter plugin is enabled')\n  }\n\n  filter_metadata(packageInfo: Readonly<Manifest>): Promise<Manifest> {\n    if (!this.parsedConfig.enabled) {\n      return Promise.resolve(packageInfo)\n    }\n\n    let newPackageInfo = packageInfo\n    if (this.parsedConfig.block.size > 0) {\n      newPackageInfo = filterBlockedVersions(packageInfo, this.parsedConfig.block, this.logger)\n    }\n\n    return Promise.resolve(newPackageInfo)\n  }\n}\n\nexport default FilterPlugin\n","import { Range, satisfies } from 'semver'\n\nimport { Manifest, Logger } from '@verdaccio/types'\n\nimport { BlockStrategy, PackageBlockRule, ParsedBlockRule } from './types'\n\n/**\n * Split a package name into name itself and scope\n * @param name\n */\nfunction splitName(name: string) {\n  const parts = name.split('/')\n\n  if (parts.length > 1) {\n    return {\n      scope: parts[0],\n      name: parts[1],\n    }\n  }\n  else {\n    return {\n      name: parts[0],\n    }\n  }\n}\n\nfunction getPackageClone(packageInfo: Readonly<Manifest>) {\n  return {\n    ...packageInfo,\n    'versions': {\n      ...packageInfo.versions,\n    },\n    'dist-tags': {\n      ...packageInfo['dist-tags'],\n    },\n  }\n}\n\nexport function isScopeRule(rule: PackageBlockRule): rule is { scope: string } {\n  return 'scope' in rule && typeof rule.scope === 'string'\n}\n\nexport function isPackageRule(rule: PackageBlockRule): rule is { package: string, versions: never } {\n  return 'package' in rule && !('versions' in rule)\n}\n\nexport function isPackageAndVersionRule(\n  rule: PackageBlockRule,\n): rule is { package: string, versions: string, strategy?: BlockStrategy } {\n  return 'package' in rule && 'versions' in rule\n}\n\n/**\n * Filter out all blocked package versions. If all package is blocked, or it's scope is blocked - block all versions.\n * @param packageInfo\n * @param block\n * @param logger\n */\nexport function filterBlockedVersions(\n  packageInfo: Readonly<Manifest>,\n  block: Map<string, ParsedBlockRule>,\n  logger: Logger,\n): Manifest {\n  const { scope } = splitName(packageInfo.name)\n\n  if (scope && block.get(scope) === 'scope') {\n    return { ...packageInfo, versions: {}, readme: `All packages in scope ${scope} blocked by rule` }\n  }\n\n  const blockRule = block.get(packageInfo.name)\n\n  if (!blockRule) {\n    return packageInfo\n  }\n\n  if (blockRule === 'package') {\n    return { ...packageInfo, versions: {}, readme: `All package versions blocked by rule` }\n  }\n\n  if (blockRule === 'scope') {\n    throw new Error('Unexpected case - blockRule for package should never be \"scope\"')\n  }\n\n  const newPackageInfo = getPackageClone(packageInfo)\n\n  const blockedVersionRanges = blockRule.block as Range[]\n\n  // Add debug info for devs\n  newPackageInfo.readme\n    = (newPackageInfo.readme || '')\n      + `\\nSome versions of package are blocked by rules: ${blockedVersionRanges.map(range => range.raw)}`\n\n  if (blockRule.strategy === 'block') {\n    Object.keys(newPackageInfo.versions).forEach((version) => {\n      blockedVersionRanges.forEach((versionRange) => {\n        if (satisfies(version, versionRange, { includePrerelease: true, loose: true })) {\n          delete newPackageInfo.versions[version]\n        }\n      })\n    })\n\n    return newPackageInfo\n  }\n\n  // We assume that the order of versions is already sorted\n  const nonBlockedVersions = { ...newPackageInfo.versions }\n  const newVersionsMapping: Record<string, string | null> = {}\n\n  blockedVersionRanges.forEach((versionRange) => {\n    const allVersions = Object.keys(nonBlockedVersions)\n\n    let lastNonBlockedVersion: string | null = null\n    let firstNonBlockedVersion: string | null = null\n\n    allVersions.forEach((version) => {\n      if (satisfies(version, versionRange, { includePrerelease: true, loose: true })) {\n        delete nonBlockedVersions[version]\n        newVersionsMapping[version] = lastNonBlockedVersion\n      }\n      else {\n        lastNonBlockedVersion = version\n        firstNonBlockedVersion = firstNonBlockedVersion ?? version\n      }\n    })\n  })\n\n  logger.debug(`Filtering package ${packageInfo.name}, replacing versions`)\n  logger.debug(`${JSON.stringify(newVersionsMapping)}`)\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const removedVersions = Object.entries(newVersionsMapping).filter(([_, replace]) => replace === null) as [string, null][]\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const replacedVersions = Object.entries(newVersionsMapping).filter(([_, replace]) => replace !== null) as [string, string][]\n\n  removedVersions.forEach(([version]) => {\n    logger.debug(`No version to replace ${version}`)\n    delete newPackageInfo.versions[version]\n    return\n  })\n\n  replacedVersions.forEach(([version, replaceVersion]) => {\n    newPackageInfo.versions[version] = { ...newPackageInfo.versions[replaceVersion], version }\n  })\n\n  newPackageInfo.readme += `\\nSome versions of package are fully blocked: ${removedVersions.map(a => a[0])}`\n  newPackageInfo.readme += `\\nSome versions of package are replaced by other: ${removedVersions.map(a => `${a[0]} => ${a[1]}`)}`\n\n  return newPackageInfo\n}\n"],"mappings":"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","names":["import_semver","buildDebug"]}